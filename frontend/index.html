<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File Cache Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;
        const { createRoot } = ReactDOM;

        // Your existing icon components remain the same
        const FolderIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"
                className="w-5 h-5 text-blue-500 mr-2">
                <path d="M4 20h16a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.93a2 2 0 0 1-1.66-.9l-.82-1.2A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2Z" />
            </svg>
        );

        const FileIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
                stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"
                className="w-5 h-5 text-gray-500 mr-2">
                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
                <polyline points="14 2 14 8 20 8" />
            </svg>
        );

        const LoadingSpinner = () => (
            <div className="flex justify-center items-center h-64">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500"></div>
            </div>
        );

        function GlobalProgress({ progress }) {
            if (!progress || progress.active_jobs === 0) return null;

            const formatSpeed = (bytesPerSecond) => {
                if (bytesPerSecond === 0) return '0 B/s';
                const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s', 'TB/s'];
                const i = Math.floor(Math.log(bytesPerSecond) / Math.log(1024));
                return `${(bytesPerSecond / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
            };

            return (
                <div className="bg-blue-50 px-4 py-2">
                    <div className="flex items-center justify-between max-w-7xl mx-auto">
                        <div className="text-sm text-blue-700">
                            Active Jobs: {progress.active_jobs} |
                            Speed: {formatSpeed(progress.total_speed)}
                        </div>
                        <div className="w-1/2">
                            <div className="w-full bg-blue-200 rounded-full h-2">
                                <div
                                    className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                                    style={{ width: `${progress.overall_percent}%` }}
                                ></div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        function FileExplorer() {
            const [currentPath, setCurrentPath] = useState('');
            const [entries, setEntries] = useState([]);
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState(null);
            const [globalProgress, setGlobalProgress] = useState(null);
            const [precachingItems, setPrecachingItems] = useState(new Set());

            // Initialize path from URL on component mount
            useEffect(() => {
                const path = window.location.pathname.replace(/^\/files/, '');
                setCurrentPath(path.startsWith('/') ? path.slice(1) : path);
            }, []);

            // Update URL when path changes
            useEffect(() => {
                const url = currentPath ? `/files/${currentPath}` : '/files';
                window.history.pushState({ path: currentPath }, '', url);
            }, [currentPath]);

            // Handle browser back/forward buttons
            useEffect(() => {
                const handlePopState = (event) => {
                    const path = (event.state && event.state.path) || '';
                    setCurrentPath(path);
                };
                window.addEventListener('popstate', handlePopState);
                return () => window.removeEventListener('popstate', handlePopState);
            }, []);

            const formatSize = (bytes) => {
                if (bytes === 0 || !bytes) return '0 B';
                const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                const i = Math.floor(Math.log(bytes) / Math.log(1024));
                return `${(bytes / Math.pow(1024, i)).toFixed(2)} ${sizes[i]}`;
            };

            const formatDate = (timestamp) => {
                return new Date(timestamp * 1000).toLocaleString();
            };

            const fetchDirectory = async (path) => {
                setLoading(true);
                try {
                    const response = await fetch(`/api/browse/${path}`);
                    if (!response.ok) throw new Error('Failed to fetch directory');
                    const data = await response.json();
                    setEntries(data);
                } catch (err) {
                    setError(err.message);
                } finally {
                    setLoading(false);
                }
            };

            const updateEntryCachedSize = (path, cachedSize) => {
                setEntries(prevEntries =>
                    prevEntries.map(entry =>
                        entry.path === path
                            ? { ...entry, cached_size: cachedSize }
                            : entry
                    )
                );
            };

            const monitorCacheProgress = async (path) => {
                try {
                    const response = await fetch(`/api/cache-progress/${path}`);
                    if (!response.ok) {
                        if (response.status === 404) {
                            setPrecachingItems(prev => {
                                const newSet = new Set(prev);
                                newSet.delete(path);
                                return newSet;
                            });
                            fetchDirectory(currentPath);
                            return;
                        }
                        throw new Error('Failed to fetch cache progress');
                    }

                    const progress = await response.json();
                    if (progress.cached_size !== undefined) {
                        updateEntryCachedSize(path, progress.cached_size);
                    }

                    console.log(precachingItems, precachingItems.has(path));

                    // TODO: fix the conditon to stop the polling
                    if (precachingItems.has(path) || true) {
                        setTimeout(() => monitorCacheProgress(path), 1000);
                    }
                } catch (err) {
                    console.error('Error monitoring cache progress:', err);
                }
            };

            const startPrecache = async (path) => {
                try {
                    await fetch(`/api/precache/${path}`, { method: 'POST' });
                    setPrecachingItems(prev => new Set([...prev, path]));
                    fetchGlobalProgress();
                    monitorCacheProgress(path);
                } catch (err) {
                    setError(err.message);
                }
            };

            const fetchGlobalProgress = async () => {
                try {
                    const response = await fetch('/api/cache-progress/');
                    if (!response.ok) return;
                    const progress = await response.json();
                    setGlobalProgress(progress);

                    if (progress.active_jobs > 0) {
                        setTimeout(fetchGlobalProgress, 1000);
                    }
                } catch (err) {
                    console.error('Error checking global progress:', err);
                }
            };

            useEffect(() => {
                fetchDirectory(currentPath);
            }, [currentPath]);

            useEffect(() => {
                fetchGlobalProgress();
            }, []);

            const navigateToPath = (path) => {
                setCurrentPath(path);
            };

            return (
                <div>
                    <GlobalProgress progress={globalProgress} />
                    <div className="p-4">
                        <div className="flex items-center space-x-2 mb-4">
                            <button
                                onClick={() => navigateToPath('')}
                                className="px-2 py-1 text-blue-600 hover:text-blue-800"
                            >
                                Root
                            </button>
                            {currentPath.split('/').filter(Boolean).map((segment, index, array) => (
                                <React.Fragment key={segment}>
                                    <span>/</span>
                                    <button
                                        onClick={() => navigateToPath(array.slice(0, index + 1).join('/'))}
                                        className="px-2 py-1 text-blue-600 hover:text-blue-800"
                                    >
                                        {segment}
                                    </button>
                                </React.Fragment>
                            ))}
                        </div>

                        {error && (
                            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
                                {error}
                            </div>
                        )}

                        <div className="bg-white rounded-lg shadow">
                            {loading ? (
                                <LoadingSpinner />
                            ) : (
                                <table className="min-w-full">
                                    <thead>
                                        <tr className="bg-gray-50">
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Name</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Size</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Created</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Cache Size</th>
                                            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody className="divide-y divide-gray-200">
                                        {entries.map((entry) => (
                                            <tr key={entry.path} className="hover:bg-gray-50">
                                                <td className="px-6 py-4">
                                                    <div className="flex items-center">
                                                        {entry.is_dir ? <FolderIcon /> : <FileIcon />}
                                                        <button
                                                            onClick={() => entry.is_dir && navigateToPath(entry.path)}
                                                            className="text-sm font-medium text-gray-900 hover:text-blue-600"
                                                        >
                                                            {entry.name}
                                                        </button>
                                                    </div>
                                                </td>
                                                <td className="px-6 py-4 text-sm text-gray-500">
                                                    {!entry.is_dir && formatSize(entry.size)}
                                                </td>
                                                <td className="px-6 py-4 text-sm text-gray-500">
                                                    {formatDate(entry.created_time)}
                                                </td>
                                                <td className="px-6 py-4 text-sm text-gray-500">
                                                    {formatSize(entry.cached_size)}
                                                    {precachingItems.has(entry.path) && (
                                                        <span className="ml-2 inline-block">
                                                            <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-500"></div>
                                                        </span>
                                                    )}
                                                </td>
                                                <td className="px-6 py-4 text-sm">
                                                    <button
                                                        onClick={() => startPrecache(entry.path)}
                                                        className="text-blue-600 hover:text-blue-900"
                                                        disabled={precachingItems.has(entry.path)}
                                                    >
                                                        {precachingItems.has(entry.path) ? 'Precaching...' : 'Precache'}
                                                    </button>
                                                </td>
                                            </tr>
                                        ))}
                                    </tbody>
                                </table>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        function App() {
            return (
                <div className="min-h-screen bg-gray-100">
                    <nav className="bg-white shadow-sm">
                        <div className="max-w-7xl mx-auto px-4 py-3">
                            <h1 className="text-xl font-semibold text-gray-800">File Cache Manager</h1>
                        </div>
                    </nav>
                    <main className="max-w-7xl mx-auto">
                        <FileExplorer />
                    </main>
                </div>
            );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>